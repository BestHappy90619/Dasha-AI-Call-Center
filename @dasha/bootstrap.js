// DONT EDIT THIS CODE!
// AUTOGENERATED BY DASHA STUDIO
/* eslint-disable no-undef */

import axios from "axios";
import * as dasha from "@dasha.ai/sdk";
import TelegramAvatar from "./telegram.js";

const getConversationInput = async (app, conv) => {
  const endpoint = "http://localhost:" + process.env.DASHA_SDK_OBSERVER_PORT + "/conversation/input";
  return await axios
    .get(endpoint, {
      params: { jobId: conv._jobId },
      headers: { authorization: "Bearer " + app.account.apiKey },
    })
    .catch((e) => {
      console.error(e);
      return {};
    });
};

let _telegramAvatar;
export const telegramInterceptor = ({ chat, endpoint }) => {
  _telegramAvatar = new TelegramAvatar(chat, endpoint);

  const QueuedExecute = dasha.QueuedConversation.prototype.execute;
  dasha.QueuedConversation.prototype.execute = async function () {
    return await telegramInterceptorPatch(QueuedExecute, this);
  };

  if (dasha.SingleConversation) {
    const SingleExecute = dasha.SingleConversation.prototype.execute;
    dasha.SingleConversation.prototype.execute = async function () {
      return await telegramInterceptorPatch(SingleExecute, this);
    };
  }
};

export const telegramInterceptorPatch = async (executeFn, conv) => {
  if (_telegramAvatar) {
    await _telegramAvatar.disconnect().catch(() => 0);
    const fn = "_sandbox_interceptorFunction";
    conv._application.setExternal(fn, async (args) => {
      try {
        return await _telegramAvatar?.userMessage(args);
      } catch {
        return { messages: [], error: false, transaction: "" };
      }
    });
  }

  process.on("exit", async () => {
    await _telegramAvatar?.disconnect();
  });

  conv.input._sandbox_interceptorEnabled = true;
  conv.on("debugLog", (log) => {
    if (log?.msg?.targetNodePath === "node::_sandbox_interceptorNode") {
      _telegramAvatar?.setCurrentNode(log.msg.sourceNodePath);
      return;
    }

    if (log.msg?.msgId === "JobCommunicationMessage") {
      _telegramAvatar?.connect(log.msg.content.jobId);
      return;
    }

    if (log.msg?.msgId === "RawTextChannelMessage" && log.incoming === false) {
      _telegramAvatar?.dashaMessage(log.msg.text);
      return;
    }
  });

  try {
    const response = await executeFn.bind(conv)();
    await _telegramAvatar?.disconnect();
    return response;
  } catch (e) {
    await _telegramAvatar?.disconnect();
    throw e;
  }
};

const customDeployExecutePatch = async (executeFn, conv, args) => {
  // fetch context configuration from dasha studio
  if (conv._jobKey.startsWith("__posted_conversation:")) {
    const response = await getConversationInput(conv._application, conv);
    conv.input = Object.assign(conv.input, response.data);
  }

  return await executeFn.bind(conv)(...args);
};

export const customDeployBootstrap = () => {
  const QueuedExecute = dasha.QueuedConversation.prototype.execute;
  dasha.QueuedConversation.prototype.execute = async function (...args) {
    return await customDeployExecutePatch(QueuedExecute, this, args);
  };

  if (dasha.SingleConversation) {
    const SingleExecute = dasha.SingleConversation.prototype.execute;
    dasha.SingleConversation.prototype.execute = async function (...args) {
      return await customDeployExecutePatch(SingleExecute, this, args);
    };
  }
};

if (process.sandbox == null) {
  customDeployBootstrap();
}
